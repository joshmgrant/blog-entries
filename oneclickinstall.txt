One of the cooler things that I've accomplished lately is a one-click setup for the installation of a main app that I test on a regular basis. I'm surprised at how convenient this is for my daily work. I recommend it. 

Newer automated testers (like myself) seem to struggle with getting comfortable with automating in general. First you have to wrap your head around writing and running automated tests, but there's much more to the story than that. A good thing to become familiar with is _task_ automation, in addition to _test_ automation. For me, test automation is when a process that inquires or tries to discover information about an application under test. Test automation might produce results that are unexpected, or may find information out that the tester didn't know about. In general, automating a test can be either a good idea or not depending on the specific situation. Some forms of testing are better suited to automation than others. 

In slight contrast, _task_ automation is when a given task is automated. I think of a task as a predictable, stable process that is more utilitarian in nature. It's something that information doesn't need to be discovered for. You already know exactly what you need to know about the task, and you just need to complete it. Tasks should be automated as much as possible, for simplicity and consistency. Automating tasks can be a great time and effort saver. 

A perfect example of a task is installing an application to test. The installation process itself may be interesting and helpful to test, but most of the time (in my case) I just want to install the app in some standard way. For the app that I work on now, which I will refer to as TestApp (name changed to protect the innocent), I fully install it on a clean machine around once a day to do further testing. To me, this is a good candidate for task automation. 

A bit more detail on TestApp: It is an enterprise-y Windows desktop application. In this case, the install user a Wizard-style interface, which is a series of dialogs with various options that can be selected on each dialog. There are about 8 separate dialog pages in a usual install case. As well, since I'm installing this on a clean machine, I also need to install a local SQL server, which is optionally included with TestApp. In this case, TestApp is bundled with MS SQL Server Express which also requires some clicking through to install it, although it has many fewer options. All told, it would take about 10 minutes to install the application with a local SQL server from beginning to end. 

Currently the installation has been automated as part of an acceptance test in SilkTest. Being the reasonably good end user simulation tool that it is, SilkTest can handle choosing options in radio lists and entering file paths into text boxes without any issue. This part took care of the actual work of going through the installation step-by-step. In the past I used this part of the acceptance test to install TestApp, but it takes longer than needed due to checks added because it is part of an larger test set. Also, since SilkTest generates results files based on running test plans, running only part of the acceptance test sort of screwed up the history of actual acceptance test run results. So, I decided to write a standalone SilkTest plan that only installs TestApp.

Writing a standalone script for just installing TestApp worked out well, and I was able to reuse a bunch of exiting code. But then I started to wonder what would happen if someone else not so familiar with SilkTest wanted to run this installation script. Or if the script file was accidentally edited to change the setup. Or what if I were just lazy and wanted to click something to do the work for me. It turns out that SilkTest has a pretty good command-line interface, but that would still require inputing things like file names or options. Here, that was too much: I wanted to be really lazy. I decided to take the extra step and write a script to produce an .exe that can simply be double-clicked to run.  

First I tried writing a simple shell script. However, the Windows command line enviroment kind of sucks. For example, it doesn't support UNC directory names, so I can't easily navigate to networked locations, which was important here. So I decided instead to use my favourite tool, Python. I wrote this simple script which I call runInstall.py: 

from subprocess import call

call(["runtime.exe", "-q", "-r", "InstallationPlan.pln"])

It's pretty straightforward. This sends a system call to execute runtime.exe (SilkTest) with the given options and test plan, and that's it. This is good except that it would require Python to be installed on the given machine which isn't an option where I work. So I compiled this into a Windows executable using py2exe, which was a simple additional step. This lets runInstall.py produce runInstall.exe, copy this and needed files to the same directory as the installation plan script, and we're off to the races. Even cooler is that if I did decide to change the installation details, I don't have to change runInstall.exe, only InstallationPlan scripts. It also requires zero knowledge of Python. Now I can install TestApp with one double-click, and do some other things in the meantime. Productivity win. 