A while back, I've wrote about how [Selenium could be the next XML](https://simplythetest.tumblr.com/post/177212136130/selenium-as-the-next-xml), since they are both W3C standards. One of the advantages of these technologies being standards is that it becomes easier for other technologies to use and build on top of them. It's a lot easier to design an electronic device, for example, that has a standard source of electrical power from a standardized power outlet and plug design.

For whatever reason, folks over the years have [hated](https://blog.codinghorror.com/revisiting-the-xml-angle-bracket-tax/) [on](https://myarch.com/why-xml-is-bad-for-humans/) XML. I do agree that as a human editable markup it can be cumbersome, but that's only one way to look at it. Thinking of XML more generically can provider better insight to why it's a good technology to build on instead of thinking of it in markup/"XML as code" terms.

If you're a fan of my blog, you've likely heard of [Jenkins CI](https://jenkins.io/index.html). If you're not familiar with Jenkins, it is a popular open-source continuous integration system which allows executing various tasks on one or more computers from one central interface. Lots of people use Jenkins, and lots of people maintain Jenkins instances. 

Under the hood, Jenkins really consists of Java and a bunch of XML files. One team I worked on had our own Jenkins instance, and we would regularly save configurations and jobs in source control. Since Jenkins jobs and configurations are all XML, this was pretty straightforward. We could even diff two versions of our setup, and move to a new deployment of Jenkins in an almost automated fashion. In part, Jenkins was designed this way because XML has a reliable standard. If you've used Jenkins even briefly, you've edited and created XML files, even if the actual work on these files has been abstracted away from you. 

Another example is the use of JUnit XML files as a defacto standard for parsing automated test results. Many tools for test automation can parse JUnit XML files and display test results in a straightforward way, and many test automation tools have options to output results into a JUnit XML format even if they are not JUnit based. Again, if you've ever looked at a test result dashboard that you didn't completely create from scratch, you're likely making use of an XML file. Once again, XML was probably chosen because it's a standard markup suited for data like automated test results.

These are only two examples from my career on how I've "used" XML files without directly working with them. I'm sure there are other examples out there. My point is that building on top of standard technologies can be quite useful and provide better technologies in a variety of problem spaces.

Selenium could be treated similarly, and to a large extent has been. Tools such as [Watir])(http://watir.com), [Nerodia](https://nerodia.readthedocs.io/en/stable/), [Selenide](https://selenide.org/), and [Protractor](https://www.protractortest.org/#/) have been built directly on the Selenium Webdriver. These tools have been created for a specific problem space (browser test automation) while Selenium was not created for this space. While these tools haven't completely abstracted away the inner workings of the webdriver, they arguably make this possible. They also provide a better interface to work with for test automation than working with the WebDriver directly. 

Most technologies build on top of previous technologies. Selenium and test automation should be no different.