I have to blog about this. 

Today, I found a post saying that FogBugz - a popular project management app for software teams - has *stopped using its in-house proprietary programming language Wasabi* [http://blog.fogcreek.com/killing-off-wasabi-part-1/]. 

TL;DR: This whole story should be a case study in computer science and software engineering programs everywhere. 

The back story is fairly straightforward. FogBugz is an application created by the software company Fog Creek. FogBugz was first written for Windows in the early 2000s. Because of this, FogBugz was written mainly in VBScript, a scripting language on Windows machines. In 2005, the decision was made to build FogBugz for Linux platforms as well. Since VBScript was no longer an option for development on Linux, there was a problem of how to build for non-Windows platforms. The solution to this problem was to write a custom programming language called Wasabi using a custom compiler written in C#. 

One of the main individuals at Fog Creek working on these projects was the well-known *Joel Spolsky* [http://www.joelonsoftware.com/]. He's a software developer who's worked at Microsoft and elsewhere and has written blog posts now seen as classics in the software development community.  One of his more famous posts talks about big re-writes and how they are *largely a bad idea* [http://www.joelonsoftware.com/articles/fog0000000069.html]. As porting FogBugz from Windows to Linux could've merited a big re-write, Joel was a proponent of using a custom language to avoid writing new code and reuse existing code. 

After ten years, the result of this decision was the abandon Wasabi altogether in FogBugz. I can't say I'm surprised. 

What makes this story so fascinating is that 1) it's a great example of a software development failure and 2) it's mostly public. There are posts by Joel of his *decision* [http://www.joelonsoftware.com/items/2006/09/01.html] *to use* [http://www.joelonsoftware.com/items/2006/09/01b.html] Wasabi as well as *critiques from his peers* [http://blog.codinghorror.com/has-joel-spolsky-jumped-the-shark/]. This was around ten years ago, when the software world was quite different, but some of the points are still relevant now (and will be for the foreseeable future). As well, this might be a /software development/ failure, but not necessarily a /business/ failure; FogBugz is still around and making money, perhaps even some directly due to the decision to use an in-house language. While Wasabi didn't kill off FogBugz, it probably made things more difficult for a longer time than expected. My guess is that there won't be much *lost love* [http://jacob.jkrall.net/wasabi-the-parts/introduction.html] for Wasabi from individuals at Fog Creek.

Based on all that, I'm sure a book or even a short course could be written discussing some of what happened with Wasabi and FogBugz. Here's some things that have leapt out at me looking at this story: 

-Technical Decisions Are Social Decisions: The idea of developing a new compiler or programming language in order to reuse significant amounts of code is not a bad idea from a purely technical standpoint. Doing so is creating a new tool to get over a speed-bump, and writing a compiler to build from one language to another is basically a solved problem. But the social overhead of working with an in-house language can be enormous. Getting help on a particular issues is difficult because you can't use StackOverflow or hire an Senior Wasabi Developer with 5+ years experience. Training becomes challenging and longer because new devs need to be taught a new language and tooling on top of their other duties. Similarly, when a developer leaves the company or team their knowledge isn't easily replaced since they may be the sole person anywhere with this knowledge. The core problem is that all knowledge and  understanding of a custom language is internal. There's no way easy way to share or reproduce what people know about the language.

Thanks to Conway's Law, an internally created programming language takes on all the quirks of the organization producing it, which becomes a big time suck. Quirky, surprising bits of a language might be enjoyable to language designer or architect but are dreadful to a user. It also means unlearning how other more mainstream languages work. These aspects probably contributed to making working with Wasabi a crappy experience for developers, creating a vicious cycle of the language getting worse leading to even crappier experiences. My guess is that this is the biggest reason Wasabi was removed. People hated it working with it so much that any technological benefits it had were nullified.

-Proprietary Closed-Source Languages Are Awful: I have some experience with this. My first programming job was working with the *4Test language* [http://sqa.fyicenter.com/FAQ/SilkTest/What_is_4Test_.html], a proprietary language created originally by Borland for writing UI automation scripts. While the language itself wasn't too bad, working with it on a daily basis was pretty tough. Searching online for resources was limited because there was basically no community outside of the language's vendor, Microfocus. Wasabi had these problems but an order of magnitude worse. With 4Test, at least Microfocus provided support and some training materials (for a fee). With Wasabi, Fog Creek was on their own. 

Plus, because programming languages are such a core tool for developers to work with, even the slightest irks can cascade into blocking issues. One time working with 4Test I put an integer value into a conditional. How does 4Test evaluate that? I had no idea. There was nothing relevant in the formal documentation with the language and I'm not sure Microfocus support would necessarily know the answer. As a result, I guessed the functionality based on my experience and went from there. With mainstream languages, developers can turn to a formal spec or community understanding. I had no such choice. Closed-sourced language tend to stagnate, with fixes and improvements being slow to arrive. Proprietary languages mean little to no community and little shared knowledge to tap into. Combining the two shows where languages go to die.

-Language Design Is Very Hard: Programming languages are difficult as software projects. It's easy to have both feature creep and explosive complexity since any given feature has to be supported one-hundred percent from the time it is introduced. Features may also interact in strange and unexpected ways, even in *widely used languages* [http://archive.oreilly.com/pub/a/javascript/excerpts/javascript-good-parts/awful-parts.html]. It can also be difficult to design a language well for good usability without violating good design ideas like the *Principle of Least Surprise* [https://en.wikipedia.org/wiki/Principle_of_least_astonishment], and that's even without getting into security or performance concerns.

Consider the mainstream languages of C#, C, C++ and Java. All of these languages have similar syntax, similar features such as OOP constructs and typing and vaguely similar file structuring concepts. Most of their differences are in specific, narrow areas such as memory management. In many ways these languages are not too different. Ruby, Perl and PHP are languages that can also be grouped this way. This isn't an accident nor laziness on the part of language designers. Coming up with a new programming language is a massive project and can create incredible amounts of complexity. Undertaking this task in an organization already working on other projects could be a real drain on already scarce resources.

-One Person Can Make the Difference: Writing and maintaining commercial software is usually done by a team. Each individual on that team might have a role or strength in a particular discipline that helps the team move forward. However, it's often one or two individuals that can really affect change on a team, for better or worse. Joel Spolsky's enthusiasm toward creating a custom programming language and compiler over more conventional options likely played a big part in Wasabi's creation even if it was not shared by other team members. Some people probably thought using a custom language wasn't the best idea, or perhaps even despised the idea. It's even possible that disdain for Wasabi was the majority decision. But because Wasabi had a vocal champion, it won out in the short term. Having such a champion in a software team or community can be highly beneficial or vastly crippling depending on the context. Either way, the notion of meritocracy - that "only the code matters" - is not really true. 

All of these issues are critical for computer science and software engineering majors everywhere, or anyone else interested in working in software development for a living. There's so much more to making good software than writing a bunch of code.
